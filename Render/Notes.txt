


******
TODOS:

Priority To Do List:
*binding textures and unbinding textures, renderable class and stuff	, delete //probably going to be useless stuff, replace code with binary serach algorithm -> yup
*refactor code to have member variables have pointers instead of references -> yup
*doesn't load all meshes without textures, just a color -> yup
*put classes in different folders to organize code -> yup
*refactor code for forward declarations -> yup
*cubemaps
*light deflection + refraction thing

-Material reference in Renderable.h - Material Class - texture renderable should have its own copy of texture, how to do this with ref&point; Material has color, light stuff and a pointer to a texture, sepaetare changing stuff and nonchanging stuff
-find where I use new and make sure I properly deallocate memory
-loads obj uvs, but uvs are messed up -> next meeting;
make load any kind of image format -> kinda, prerequisite of no alpha channel image
post processing stuff -> hud - text + fonts, other interactable stuff
transformations with layer -> kinda, don't know what else to do
msaa in OpenGL etc.
sounds
should game and window in Engine.h be const, should Game methods be const too, effects throughout code okay?
browser

fix change fov scroll in
change scrolling so it stays the same even when cursor is out of focus

passing Tim::getDelta() as a double vs a float vs something even more accurate

Not necessary to do pointlights/spot lights, just as final touches
-way to organize point lights in vector -> 
getters for position
popthem off
add them back on
-pointlights don't entirely work

spot lights

******
Fixes:

change up all the paramters and make them const stuff
getters return const stuff

indices Mesh addData

references by Texture Class

fragmentshader.fs todo, should i use glEnable(GL_TEXTURE2D) and glDisable(GL_TEXTURE2D)

replace input() todo

change up PhongShader and make it a singleton class
make private variables all static

Watch Companion Video on Lighting
Make-> float diffuseFactor = dot(direction, normal); //to see what happens, opposite shading?

Control k+d for all files

change location of uniform variables in phongFragment.fs

phongFragment todo

refactor shader class so methods are all overloaded setUniform
change shader char* parameters to std::string&

make get methods return const values

rename vertices to positions

rename variables in shaders to make it more comprehensible, in texturesVS, out texturesFS

Take out code in TODO in PhongShader.cpp

substitute code from generateDataMatrix() directly into addData() method in Mesh.cpp

no uvs generated from cube.obj, why?

make it so that if there is not texture, set it to a single color

why does model * normal make the light stay the same with it?

Delegating constructors in Texture.cpp

change base to baselight

make specularExponent and specularPower consistent

const method is just changing that object right, can still be changing parameter values

**********
Notes:
Window->Reset Window LayoutWindow->Reset Window Layout

Remove default constructor of Texture since its not necessary -> Make pointer if should not need to initialize when declared

filesutils.cpp: return pixels instead of return result -> Library should clean up other stuff by itself, not just variables present

okay to use new, manage memory yourself

texture = Texture("res/textures/Hi.png"); vs texture("res/textures/Hi.png"); //second has error -> Visual Studio Directory

default argument should only be present when declared, only variable (without = value) should be present in implementation

universal zero initializer -> = 0;

emplace_back() better than put_back()

const variables better than sending in a uniform in GLSL

images -> no alpha

mvp is calculated from left to right, thus mvp

construcot initializer list can use same variable names as parameter names

better to use pointers instead of references as member variables
-so in code you understand that you're using a reference and not an actual variable
-better to have a vector of pointers than a vector of references

vectors manage all the memory they allocate for you
-everything is abstracted away from its copy constructor, destructor for cleaning, etc
-just use normally (like in Java)

allocated memory lasts for liftime of program unless its deleted

renderables can alter its own copy of its texture, can't alter the texture used by all renderables

header files can have includes of other header files so even though you may not include one, it may still be covered

always use forward delcares, declare class in header, and include includes in .cpp


wait is it bad to use new like this all the time though
why would it be? you'll be deleting them in the destructor i assume okay
and also why do forward declarations have to use pointers (it can also be references)
the compiler has no type information about the thing you're forward declaring in the header, so when it tries to create the
structure of the class in memory, it doesnt know the contents, since 
by forward declaring, you're only stating that a class/struct with that name exist
you can make a pointer because that doesn't require type information, it only states that there is a pointer to some class with this name
make sense? yeah lemme copy this down

-use arrows underneath file top left corner of Visual Studio
-1. use Visual Studio Filters as make-beieve folderss
-2. manualy replace filters with folders
-class redefinnition include error
-forward declare a class and extended that error -> uses self include and remove forward declaration
-trying to template undefined types
-why const int& i = int& but not const int* i = int*, references are const naturally, can't "point" to something else


*******
Coding Guidelines:
better to use pointers instead of references as member variables
-so in code you understand that you're using a reference and not an actual variable
-better to have a vector of pointers than a vector of references
use pointers if it referes to something else
use the actual variable if it is unique to each object
-use const references as setter methods to set normal variable though

use member initalizer lists, parameter names can be same as member variable names
also delegated constructor "initalizers"

if code for a method is not long (~1or2 lines), then just put code in header file
except if code is a constructor, must be defined seperately in .cpp file

always pass in const references instead of by value

when having a "getter" that doesn't return a const reference, call it a "alterVariable" method that returns a reference to the member variable

always keep in mind of the possiblity of default constructors

empty methods in a .cpp file, do this: 
~Class       void someMethod()
{ }			 { }
empty methods in header file, do this: someMethod(){} 

when including files in .h:
#pragma once
enter for line of space
first standard c++ library includes
then imported library includes
enter for line of space
//use forward declares

when including files in .cpp:
first standard c++ library includes
enter for line of space
imported library includes (if necessary)
enter for line of space
include header of this file
enter for line of space
use header for files you made
enter for line of space
//use forward declares

then self made header file includes

don't put all includes in the header file, only put ones that are necessary in header file, and put others required by .cpp file in the .cpp file
makes it more efficient when compiling, takes less time to look at all those includes

make header files have paramter names that are meaninful since those are the ones that are ultimately going to be looked at
you can be a little more free in the .cpp files

use folders to organize code -> Ultimately if making opensource
if there are at least 5 classes (~10 files including header and .cpp files), then categorize and make a folder for each
or use Visual Studio filters

pointers as member pointer variables using forward declaration
pointers in paramterers only if class has that as its member pointer
references in parameters only if class does not use that as its member pointer
returns const references as usual -> dont have to allocate memory all the time, too much work
vectors of pointers

-includes for class's members -> more the better in forward declarations in header file, .cpp should have a lot of includes too
-convention for code in header file, have only function prototypes, getters and setters for one to two lines except if its constructors must be defined seperately in .cpp file, doesn't have to include self made headers
-renderables const constructor, const getter but nonconst member

namspaces should be used like this:
namespace ginkgo {
}
instead of 
namespace ginkgo
{
}
*******
Some preconditions that must be satisifed before using this engine:
Images should have the alpha channel removed -> Gimp remove alpha channel

*******
Bugs:
READ ALL ERRORS
Consider possiblities of waterfall error

What to do when not drawing anything to the screen:
check uniforms
check size of each collection of data when allocating
generateDataMatrix is wrong
check if its just drawing it not on screen
check normals and vertices size 

